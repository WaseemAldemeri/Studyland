# üìö Studyland

**Studyland** is a full-stack, real-time social study platform designed to help users track their study hours, analyze their performance, and study alongside friends in virtual rooms.

Built with a focus on **Clean Architecture** utilizing **Vertical Slices** and **Domain-Driven Design (DDD)** principles, it leverages the power of **.NET 9** for a robust backend and **React 19** for a high-performance, responsive frontend.

-----

## üèóÔ∏è Architecture: Clean Architecture & Vertical Slices

The solution follows a strict **Clean Architecture** approach, further organized by **Vertical Slices** within the Application layer. This ensures that all logic related to a specific feature (e.g., "Sessions")‚Äîfrom API endpoints to database queries‚Äîis cohesive and easy to maintain.

### Backend Layers

  * **`Domain`**: The core of the application. Contains enterprise logic and entities (`User`, `Session`, `Topic`) with zero external dependencies.
  * **`Application`**: Implements business logic using **CQRS** (Command Query Responsibility Segregation) via **MediatR**.
      * **Vertical Slices**: Features are organized by domain area (e.g., `Application/Sessions/Commands/CreateSession.cs`), keeping related logic together.
      * **Behaviors**: Cross-cutting concerns like Validation are handled via MediatR Pipeline Behaviors.
  * **`Persistence`**: Implements database access using **Entity Framework Core** with SQL Server.
  * **`API`**: The entry point, containing minimal controllers that delegate execution immediately to MediatR.

-----

## ‚ö° End-to-End Type Safety

One of the project's core philosophies is eliminating "magic strings" and runtime errors through rigorous type safety across the full stack.

### 1\. Auto-Generated API Client

The API endpoints return DTOs with precise annotations. We utilize the OpenAPI specification generated by the backend to automatically build the frontend client.

  * **Tooling**: `openapi-typescript-codegen` scans the live Swagger/OpenAPI JSON.
  * **Benefit**: This generates a fully typed **Axios client** for React. If a DTO property changes in C\#, the frontend build will fail immediately, guaranteeing perfect synchronization between backend and frontend.

### 2\. Type-Safe SignalR Wrapper

Standard SignalR calls like `hub.invoke("MethodName")` are error-prone. I implemented a **generic TypeScript wrapper** to enforce type safety on real-time events.

  * **Implementation**: By defining interfaces for `ServerToClientEvents` and `ClientToServerEvents`, the wrapper ensures that you can only invoke methods that actually exist on the Hub, with the correct payload types.

-----

## üß† Deep Dive: The Real-Time Presence System

One of the most complex parts of Studyland is managing the real-time state of users (Online, Studying, On Break) without overloading the database. This is achieved through a sophisticated **in-memory state machine** supported by background workers.

### 1\. The `PressenceService` (Singleton)

This service acts as the source of truth for all active WebSocket connections.

  * **Connection Mapping**: It maintains concurrent dictionaries to map `ConnectionId` ‚Üî `UserId` ‚Üî `ChannelId`.
  * **State Management**: When a user joins, their profile is fetched from the DB once and cached. Subsequent updates mutate this in-memory state, ensuring **O(1)** performance.

### 2\. Custom Hooks (`usePressence`)

On the frontend, complex real-time logic is abstracted into custom hooks like `usePressence`.

  * **Role**: Manages the subscription to SignalR events and synchronizes local React state with the server's in-memory presence list, keeping UI components declarative.

### 3\. Background Jobs (Hosted Services)

To maintain data integrity and automate state transitions, two `IHostedService` jobs run in the background:

  * **`ZombieSessionsKiller`**:

      * **Problem**: If a user's browser crashes or internet disconnects abruptly, they might remain "Online" or "Studying" in the memory cache indefinitely.
      * **Solution**: This job runs periodically to identify "orphaned" connections (users with no active SignalR socket) and cleanly removes them or stops their study session, ensuring accurate room listings.

  * **`StudyTimerMonitor`**:

      * **Problem**: When a user starts a timer (e.g., 25-minute Pomodoro), the server needs to know exactly when it ends to update their status.
      * **Solution**: Instead of relying on the client (which can be closed), this job scans the in-memory state for expired timers. It automatically transitions users from **"Studying"** to **"On Break"** and broadcasts the update to the room, ensuring synchronized timer states for all peers.

-----

## üé® UI/UX & PWA

The frontend is designed to be beautiful, responsive, and app-like.

  * **Stack**: Built with **Shadcn UI** and **Tailwind CSS** for a modern, accessible, and clean aesthetic.
  * **Animations**: Utilizes **Framer Motion** for smooth transitions and interactive feedback.
  * **PWA (Progressive Web App)**: The application is fully optimized to run on all devices. It is installable and responsive, providing a native mobile app experience directly from the browser.

-----

## üíª Code Highlights

### Custom FluentValidation Extensions

To keep validation logic readable and expressive, custom extension methods were built for **FluentValidation**.

  * **`.Required()`**: A shorthand that combines `.NotEmpty()` with a standardized error message format.
  * **`.MustExistInDb<T>`**: A powerful generic extension that validates foreign keys. It takes a generic `DbSet<T>` and automatically performs an asynchronous `AnyAsync` check against the database.

**Example Usage:**

```csharp
// Inside CreateSession.Validator
RuleFor(x => x.UserId)
    .Required()
    .MustExistInDb(context.Users); // Automatically checks DB and returns 404-style error if missing
```

-----

## üöÄ Tech Stack

### Backend

  * **Framework**: .NET 9 (ASP.NET Core Web API)
  * **Language**: C\#
  * **Database**: Microsoft SQL Server
  * **ORM**: Entity Framework Core
  * **Real-time**: SignalR (WebSockets)
  * **Architecture**: Clean Architecture, Vertical Slices, CQRS (MediatR)
  * **Validation**: FluentValidation
  * **Documentation**: OpenAPI (Swagger)

### Frontend

  * **Library**: React 19
  * **Build Tool**: Vite
  * **State Management**: TanStack Query (React Query)
  * **Styling**: Tailwind CSS, Shadcn UI
  * **Routing**: React Router v7

-----

## ‚ö†Ô∏è Limitations & Testing Philosophy

**Current Status: Manual Testing Only**

While the architecture (Clean Architecture + CQRS) is specifically designed to support rigorous Unit and Integration testing (by decoupling logic from infrastructure), **no automated tests are currently implemented** in this repository.

  * **Context**: As a solo developer optimizing for speed and feature delivery, I adopted a pragmatic approach, relying on manual testing to verify features.
  * **My Stance**: I deeply believe in the value of TDD and automated testing for long-term project health. In my commercial SaaS product (**Rufus USMLE**), I employed extensive unit testing (Jest) to ensure the reliability of critical exam engines.
  * **Future Work**: In a professional team setting, adding a test project to cover the MediatR handlers and Domain logic would be my first priority.

-----

## üõ†Ô∏è Setup & Installation

### Method 1: Docker Compose (Recommended)

Run the entire stack (Database + Backend + Frontend) with one command.

```bash
# Run via Docker Compose
docker-compose up --build
```

### Method 2: Manual Local Development

**1. Database**

```bash
docker-compose up -d db
```

**2. Backend**
Navigate to `backend/API` and run. The app will automatically apply migrations and seed data on startup.

```bash
cd backend/API
dotnet watch run
```

**3. Frontend**

```bash
cd frontend
npm install
npm run dev
```

-----

## üìú License

This project is open-source.
